/*
	This file is part of Task-Aware MPI and is licensed under the terms contained in the COPYING and COPYING.LESSER files.

	Copyright (C) 2015-2023 Barcelona Supercomputing Center (BSC)
*/

#ifndef REQUEST_MANAGER_HPP
#define REQUEST_MANAGER_HPP

#include <mpi.h>

#include <cassert>

#include "Interface.hpp"
#include "Ticket.hpp"
#include "TicketManager.hpp"
#include "util/ArrayView.hpp"
#include "util/ErrorHandler.hpp"


namespace tampi {

//! Class that manages the requests generated by non-blocking operations. It is
//! responsible for inserting the requests and its tickets to the ticket manager
template <typename Lang>
class RequestManager {
private:
	typedef typename Types<Lang>::request_t request_t;
	typedef typename Types<Lang>::status_t  status_t;
	typedef typename Types<Lang>::status_ptr_t status_ptr_t;
	typedef tampi::TicketManager<Lang> TicketManager;
	typedef tampi::Ticket<Lang> Ticket;

	//! \brief Get the number of active requests in an array
	//!
	//! \param requests The array of requests
	//!
	//! \returns The number of active requests
	static inline int getActiveRequestCount(const util::ArrayView<request_t> &requests)
	{
		int active = 0;
		for (const request_t &request : requests) {
			if (request != Interface<Lang>::REQUEST_NULL)
				++active;
		}
		return active;
	}

public:
	//! \brief Process a request generated by a non-blocking operation
	//!
	//! This function processes an MPI request that was generated by a
	//! non-blocking MPI operation. A request can be processed in a
	//! blocking manner (pausing the calling task) or non-blocking
	//! (registering an external event on the calling task). Before
	//! returing from this function, the request is nullified
	//!
	//! Once the request finishes, its status is saved in the specified
	//! location (if any), and the task is resumed or the external event
	//! is fulfilled
	//!
	//! \param request The MPI request to process
	//! \param status A pointer to the location where to save the status or STATUS_IGNORE
	//! \param blocking Whether the task should block until the request completes
	static void processRequest(
		request_t &request,
		status_ptr_t status = Interface<Lang>::STATUS_IGNORE,
		bool blocking = true
	);

	//! \brief Process an array of requests generated by non-blocking operations
	//!
	//! This function processes multiple MPI requests that were generated
	//! by non-blocking MPI operations. The requests can be processed
	//! in a blocking manner (pausing the calling task) or non-blocking
	//! (registering an external event on the calling task). Before
	//! returing from this function, the requests are nullified
	//!
	//! Once all requests finish, their statuses are saved in the specified
	//! location (if any), and the task is resumed or the external event
	//! is fulfilled
	//!
	//! \param requests The array of MPI requests to process
	//! \param statuses A pointer to the location where to save the statuses or STATUSES_IGNORE
	//! \param blocking Whether the task should block until the requests complete
	static void processRequests(
		util::ArrayView<request_t> requests,
		status_ptr_t statuses = Interface<Lang>::STATUSES_IGNORE,
		bool blocking = true
	);
};

template <typename Lang>
inline void RequestManager<Lang>::processRequest(request_t &request, status_ptr_t status, bool blocking)
{
	int finished = 0;
	int err = Interface<Lang>::test(request, finished, status);
	if (err != MPI_SUCCESS)
		ErrorHandler::fail("Unexpected return code from MPI test");

	if (!finished) {
		Ticket ticket(status, blocking);
		ticket.addPendingRequests(1);

		TicketManager &manager = TicketManager::getTicketManager();
		manager.addTicket(ticket, request);

		if (blocking) {
			ticket.wait();
		}
	}

	// Nullify the request
	request = Interface<Lang>::REQUEST_NULL;
}

template <typename Lang>
inline void RequestManager<Lang>::processRequests(
	util::ArrayView<request_t> requests,
	status_ptr_t statuses,
	bool blocking
) {
	if (requests.empty())
		return;

	int finished = 0;
	int err = Interface<Lang>::testall(requests.size(), requests.begin(), finished, statuses);
	if (err != MPI_SUCCESS)
		ErrorHandler::fail("Unexpected return code from MPI testall");

	if (!finished) {
		int active = getActiveRequestCount(requests);
		assert(active > 0);

		Ticket ticket(statuses, blocking);
		ticket.addPendingRequests(active);

		TicketManager &manager = TicketManager::getTicketManager();
		manager.addTicket(ticket, requests);

		if (blocking) {
			ticket.wait();
		}
	}

	// Nullify the requests
	for (int i = 0; i < requests.size(); ++i)
		requests[i] = Interface<Lang>::REQUEST_NULL;
}

} // namespace tampi

#endif // REQUEST_MANAGER_HPP
