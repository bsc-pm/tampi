/*
	This file is part of Task-Aware MPI and is licensed under the terms contained in the COPYING and COPYING.LESSER files.

	Copyright (C) 2015-2021 Barcelona Supercomputing Center (BSC)
*/

#ifndef REQUEST_MANAGER_HPP
#define REQUEST_MANAGER_HPP

#include <mpi.h>

#include <cassert>

#include "Environment.hpp"
#include "Ticket.hpp"
#include "TicketManager.hpp"
#include "util/ArrayView.hpp"
#include "util/ErrorHandler.hpp"


namespace tampi {

//! Class that manages the requests generated by non-blocking operations. It is
//! responsible for inserting the requests and its tickets to the ticket manager
template <typename Lang>
class RequestManager {
private:
	typedef typename Lang::request_t request_t;
	typedef typename Lang::status_t  status_t;
	typedef typename Lang::status_ptr_t status_ptr_t;
	typedef tampi::TicketManager<Lang> TicketManager;
	typedef tampi::Ticket<Lang> Ticket;

public:
	//! \brief Process a request generated by a non-blocking operation
	//!
	//! This function processes an MPI request that was generated by a
	//! non-blocking MPI operation. A request can be processed in a
	//! blocking manner (pausing the calling task) or non-blocking
	//! (registering an external event on the calling task). Before
	//! returing from this function, the request is nullified
	//!
	//! Once the request finishes, its status is saved in the specified
	//! location (if any), and the task is resumed or the external event
	//! is fulfilled
	//!
	//! \param request The MPI request to process
	//! \param status A pointer to the location where to save the status or STATUS_IGNORE
	//! \param blocking Whether the task should block until the request completes
	static void processRequest(
		request_t &request,
		status_ptr_t status = Lang::STATUS_IGNORE,
		bool blocking = true
	);

	//! \brief Process an array of requests generated by non-blocking operations
	//!
	//! This function processes multiple MPI requests that were generated
	//! by non-blocking MPI operations. The requests can be processed
	//! in a blocking manner (pausing the calling task) or non-blocking
	//! (registering an external event on the calling task). Before
	//! returing from this function, the requests are nullified
	//!
	//! Once all requests finish, their statuses are saved in the specified
	//! location (if any), and the task is resumed or the external event
	//! is fulfilled
	//!
	//! \param requests The array of MPI requests to process
	//! \param statuses A pointer to the location where to save the statuses or STATUSES_IGNORE
	//! \param blocking Whether the task should block until the requests complete
	static void processRequests(
		util::ArrayView<request_t> requests,
		status_ptr_t statuses = Lang::STATUSES_IGNORE,
		bool blocking = true
	);
};

template <>
inline void RequestManager<C>::processRequest(request_t &request, status_ptr_t status, bool blocking)
{
	int err;
	int finished = 0;
	err = PMPI_Test(&request, &finished, status);
	ErrorHandler::failIf(err != MPI_SUCCESS, "Unexpected return code from MPI_Test");

	if (!finished) {
		TicketManager &manager = Environment::getTicketManager<C>();

		if (blocking) {
			Ticket ticket(status);
			manager.addBlockingRequest(request, ticket);
			ticket.wait();
		} else {
			manager.addNonBlockingRequest(request, status);
		}
	}

	// Nullify the request
	request = C::REQUEST_NULL;
}

template <>
inline void RequestManager<C>::processRequests(
	util::ArrayView<request_t> requests,
	status_ptr_t statuses,
	bool blocking
) {
	if (requests.empty()) {
		return;
	}

	int err;
	int finished = 0;
	err = PMPI_Testall(requests.size(), requests.begin(), &finished, statuses);
	ErrorHandler::failIf(err != MPI_SUCCESS, "Unexpected return code from MPI_Testall");

	if (!finished) {
		TicketManager &manager = Environment::getTicketManager<C>();

		if (blocking) {
			Ticket ticket(statuses);
			manager.addBlockingRequests(requests, ticket);
			ticket.wait();
		} else {
			manager.addNonBlockingRequests(requests, statuses);
		}
	}

	// Nullify the requests
	for (int i = 0; i < requests.size(); ++i) {
		requests[i] = C::REQUEST_NULL;
	}
}

template <>
inline void RequestManager<Fortran>::processRequest(request_t &request, status_ptr_t status, bool blocking)
{
	int err;
	int finished = 0;
	pmpi_test_(&request, &finished, status, &err);
	ErrorHandler::failIf(err != MPI_SUCCESS, "Unexpected return code from MPI_Test");

	if (!finished) {
		TicketManager &manager = Environment::getTicketManager<Fortran>();

		if (blocking) {
			Ticket ticket(status);
			manager.addBlockingRequest(request, ticket);
			ticket.wait();
		} else {
			manager.addNonBlockingRequest(request, status);
		}
	}

	// Nullify the request
	request = Fortran::REQUEST_NULL;
}

template <>
inline void RequestManager<Fortran>::processRequests(
	util::ArrayView<request_t> requests,
	status_ptr_t statuses,
	bool blocking
) {
	if (requests.empty()) {
		return;
	}

	int err;
	int finished = 0;
	int size = requests.size();
	pmpi_testall_(&size, requests.begin(), &finished, statuses, &err);
	ErrorHandler::failIf(err != MPI_SUCCESS, "Unexpected return code from MPI_Testall");

	if (!finished) {
		TicketManager &manager = Environment::getTicketManager<Fortran>();

		if (blocking) {
			Ticket ticket(statuses);
			manager.addBlockingRequests(requests, ticket);
			ticket.wait();
		} else {
			manager.addNonBlockingRequests(requests, statuses);
		}
	}

	// Nullify the requests
	for (int i = 0; i < requests.size(); ++i) {
		requests[i] = Fortran::REQUEST_NULL;
	}
}

} // namespace tampi

#endif // REQUEST_MANAGER_HPP
